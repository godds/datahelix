# Current Behaviour
## Nullness

Nullness is a separate property of a field to its type; whether or not a field can be satisfied by null is not connected to its type.  Whether it can be generated from a given profile is determined separately to the process for determining other data that can be produced, and is generally not related to the other constraints on the field.

Whether null can be produced is calculated separately for every field. The high-level process is detailed here:

```
G<n> is a shorthand for "normal" generation.
G<v> is a shorthand for "violation" generation.

If a field is explicitly labelled as null:
 G<n> produces nulls.
 G<v> does not produce nulls.
Else if a field is explicitly labelled as not null:
 G<n> does not produce nulls.
 G<v> produces nulls.
Else (a field is not explicitly labelled either as null or not null):
 G<n> produces nulls.
 G<v> produces nulls.
```
A [hard contradiction](../generator/docs/Contradictions.md) is produced in the case where a field is labelled explicitly as null and not null, and so there is no data that can satisfy the field, and therefore no data can be produced at all. Data is not produced for any fields because fields can be conditional on each other.

Null is not affected by other statements that don't address it directly, but null statements can affect other statements. See the examples below, especially "Type Implication with explicit not null".

### Examples

Note that some of these examples need the `--allow-untyped-fields` flag to be set on the command line.

#### Type Implication
```
{ "field": "X", "is": "ofType", "value": "string" }
```

Null is not explicitly mentioned, so nulls are produced in `G<n>` and `G<v>`.

```
 G<n> produces nulls and strings.
 G<v> produces nulls, numbers and datetimes.
```

#### Type Implication with explicit null
```
{ "field": "X", "is": "ofType", "value": "string" },
{ "field": "X", "is": "null" }
```
The field is explicitly set to null, so nulls are produced in `G<n>` but not `G<v>`.

This section of the profile is saying that the field must be both a string and null. The only value that satisfies this is null because it can be produced by both parts of the statement.

This is a good example of how null is not affected by other sub-constraints, but affects the rest of the generation.

Seeing that null is explicitly set in this case means that its appearance in `G<n>` and lack of appearance in `G<v>` is already set, without caring what the rest of the sub-constraint says. For null generation, it is not important that it is an `ofType string`. Other operators like `equalTo`, `inSet` would not change whether null appears or not.

However, to see what can be generated by the `ofType string` sub-constraint, the null generation is important. Without it (see previous example), strings can be produced in `G<n>`. With it, strings cannot be produced.

```
 G<n> produces null.
 G<v> produces strings, numbers and datetimes.
```

#### Type Implication with explicit not null
```
{ "field": "X", "is": "ofType", "value": "string" },
{ "not": { "field": "X", "is": "null" } }
```
The field is explicitly set to not null, so nulls are produced in `G<v>` but not `G<n>`.
```
 G<n> produces strings.
 G<v> produces null, numbers and datetimes.
```

#### EqualTo
```
{ "field": "X", "is": "equalTo", "value": 6 }
```
Null is not explicitly mentioned, so nulls are produced in `G<n>` and `G<v>`.
```
 G<n> produces nulls and the number 6.
 G<v> produces nulls, numbers except 6 (but could still produce 6.1, 6.01, 6.001, ...), strings and datetimes.
```

#### EqualTo with explicit null
```
{ "field": "X", "is": "equalTo", "value": 6 },
{ "field": "X", "is": "null" }
```
The field is explicitly set to null, so nulls are produced in `G<n>` but not `G<v>`.

This section of the profile is saying that the field must be both equal to 6 and null. The only value that satisfies this is null because it can be produced by both parts of the statement.

```
 G<n> produces null.
 G<v> produces strings, numbers (including 6), and datetimes.
```

#### EqualTo with explicit null in anyOf
```
{
 "anyOf": [
   { "field": "X", "is": "equalTo", "value": 6 },
   { "field": "X", "is": "null" }
 
}
```
The field is explicitly allowed to be null, so nulls are produced in `G<n>` but not `G<v>`.
```
 G<n> produces nulls and the number 6.
 G<v> produces numbers except 6, strings and datetimes.
```

#### Hard Contradiction
```
{ "field": "foo", "is": "null" },
{ "not": { "field": "foo", "is": "null" }},
{ "field": "bar", "is": "ofType", "value": "string" }
```
The field "foo" can't be both null and not null, so this is a hard contradiction. No data can be produced for either field. Therefore, in `G<v>`, any data can be produced for "foo" and "bar". Note that this includes producing strings for "bar".
```
 G<n> produces no data for either field and gives an error.
 G<v> produces nulls, strings, datetimes and numbers for both fields.
```

#### Complex Example - Null Evaluation
```
{
 "if":
   { "field": "foo", "is": "equalTo", "value": 1 },
 "then":
   { "field": "bar", "is": "equalTo", "value": 2 }
}
```
There are two cases here. The first is when "foo" is "equalTo" 1 and "bar" is "equalTo" 2. This doesn't exclude null for either field, so the following combinations of (foo, bar) can be generated: (1, 2), (1, null), (null, 2), (null, null). The second case is when `{ "not": { "field": "foo", "is": "equalTo", "value": 1 } }` is satisfied. Note that this doesn't exclude (null, X) even in cases where X is not 2 or null. The only combinations that cannot be produced by `G<n>` are of the form (1, X) where X is not null or 2.


```
 G<n> produces (foo, bar):
   Everything except (1, X) where X is not null or 2.
 G<v> produces (foo, bar):
   (null, X) where X is anything (including null) except 2.
   (1,    X) where X is anything (including null) except 2.
```

## Type Implication

No operators imply type. By default, all types (and null, as detailed above) are allowed. This results in the behaviour below.

### Examples
#### inSet with different types
```
{ "field": "X", "is": "inSet", "values": ["abc", 123, {"date": "2001-02-03T04:05:06.007"}] }
```
Null is not explicitly mentioned, so nulls are produced in `G<n>` and `G<v>`.

This construction is possible because [inSet](TODO: Add link) allows any combination of types.
```
 G<n> produces "abc", 123, the date "2001-02-03T04:05:06.007" and nulls.
 G<v> produces anything but "abc", 123, the date "2001-02-03T04:05:06.007".
```

#### greaterThan
```
{ "field": "X", "is": "greaterThan", "value": 3 }
```
Null is not explicitly mentioned, so nulls are produced in `G<n>` and `G<v>`.

Type is not implied by the "greaterThan" operator. It will exclude numbers greater than three, but not values where the comparison does not make sense. For example, it does not make sense for a date to be compared to the number three, so the date will be included.

This logic also applies to `G<v>` output. It also does not exclude strings or datetimes.

```
 G<n> produces nulls, strings, datetimes and numbers (integers and decimals) greater than three.
 G<v> produces nulls, strings, datetimes and numbers (integers and decimals) less than or equal to three.
```

#### greaterThan with inSet
```
{ "field": "X", "is": "inSet", "values": ["abc", -123, 123, {"date": "2001-02-03T04:05:06.007"}] },
{ "field": "X", "is": "greaterThan", "value": 3 }
```
Null is not explicitly mentioned, so nulls are produced in `G<n>` and `G<v>`.

Strings and datetimes are not excluded by the greater than 3 operator.

For the `G<v>` output, negating the first term can produce anything but "abc", -123, 123 and the date. Negating the second term can produce anything except numbers above 3, which includes 123. So, the only value that cannot be produced in `G<v>` is 123.

```
 G<n> produces nulls, the string "abc", the integer 123 and the date "2001-02-03T04:05:06.007".
 G<v> produces everything apart from 123.
```

## Violation

The violation output could have been calculated by simply negating an entire rule or profile. This could then produce all data that breaks the original profile in any way. However, this includes data that breaks the data in multiple ways at once. This could be very noisy, because the user is expected to test one small breakage in a localised area at a time.

To minimise the noise in an efficient way, a guarantee of completeness is broken. The system does not guarantee to be able to produce violating data in all cases where there could be data which meets this requirement. In some cases this means that no data is produced at all.

In normal negation, negating `allOf [A, B, C]` gives `allOf[NOT(A), B, C]` or `allOf[A, NOT(B), C]` or `allOf[A, B, NOT(C)]` or `allOf[NOT(A), NOT(B), C]` or `allOf[A, NOT(B), NOT(C)]` or `allOf[NOT(A), B, NOT(C)]` or `allOf[NOT(A), NOT(B), NOT(C)]`. These are listed from the least to most noisy. The current system only tries to generate data by negating one sub-constraint at a time (in this case, producing only the first three).

### Intra-rule examples
#### Hard contradiction
```
"allOf": [
 { "field": "X", "is": "ofType", "value": "string" },
 { "field": "X", "is": "ofType", "value": "integer" },
 { "not": { "field": "X", "is": "null" } }
]
```
In `G<v>` this produces integers (negating just the first condition), strings (negating just the second condition) and nulls (negating just the third condition).

In `G<v>`, datetimes can only be produced by negating more than one of the sub-constraints in the allOf, which the system does not do.

```
 G<n> produces an error and no data.
 G<v> produces null, strings and integers.
```

### Inter-rule examples
#### Duplicated Rules
A:
```
{ "field": "X", "is": "null" }
```
B:
```
{ "field": "X", "is": "null" }
```
In `G<v>` this produces two files, one with the equivalent of `allOf[NOT(A), B]` and the other with the equivalent of `allOf[A, NOT(B)]`. Both of these produce a hard contradiction (and therefore no data). If the system also did `allOf[NOT(A), NOT(B)]` then it would produce some data.

```
 G<n> produces null.
 G<v> (file 1) does not produce anything.
 G<v> (file 2) does not produce anything.
```

#### Overlapping inSet
A:
```
{ "field": "X", "is": "inSet", "values": [1, 2] }
```
B:
```
{ "field": "X", "is": "inSet", "values": [2, 3] }
```
Null is not explicitly mentioned, so nulls are produced in `G<n>` and `G<v>`.

All rules are evaluated as an `allOf` in `G<n>`, and the only values that meet that are null and 2.

The first file produced for `G<v>` negates A but not B, so null and 3 are produced.

The second file produced for `G<v>` negates B but not A, so null and 1 are produced.

```
 G<n> produces null and 2.
 G<v> (file 1) produces null and 3.
 G<v> (file 2) produces null and 1.
```


